# MINT ECL-BASE Schema v0.2  
### PostgreSQL + SQLAlchemy + pgvector

## 0. Metadata
- **Subsystem:** MINT (Meaning INference Transformer)
- **Document:** MINT_ECL_BASE_Schema_v0.2.md  
- **Status:** Draft — Aligned with MINT Architecture, Invariants v0.2, and Slice Lifecycle v0.1  
- **Backend:** PostgreSQL + SQLAlchemy + pgvector  
- **Scope:** MINT-specific storage only (no duplication of GlossRP data)

---

## 1. Design Constraints

1. **No duplication of GlossRP data**
   - Term identity and canonical meaning live in **GlossRP**.
   - MINT stores only:
     - its own transform packets, and
     - its own TierSlices.

2. **GlossRP integration via business keys**
   - MINT references:
     - `term_id`
     - `term_version_id`
   - These are foreign *business keys* that come from GlossRP (`Term` / `TermVersion`), but we do not hard-couple schemas.

3. **Deterministic canonical behavior**
   - Canonical TierSlices must be deterministic under:
     - `(term_version_id, mint_version, invariants_version, density, tier)`.

4. **Lifecycle-driven generation**
   - Slice creation/regeneration follows **MINT_Slice_Lifecycle_v0.1**.
   - Not created on every request; only on specific lifecycle events.

5. **Variation mode is conceptual only**
   - No schema fields for variation/temperature.
   - Variation is documented but **not executable** in this version.

---

## 2. Core Tables Overview

MINT’s ECL-BASE consists of three main tables:

1. `mint_invariant_snapshot`  
   – Records which invariants/version were active for transforms.

2. `mint_transform_packet`  
   – One execution of MINT for a given term version + invariants.

3. `mint_tier_slice`  
   – Canonical TierSlices (T1/T2/T3) produced by a transform packet.

All connections to term meaning are via:
- `term_id`  
- `term_version_id`  

These are supplied by GlossRP / its API.

---

## 3. Table Definitions (Conceptual)

### 3.1 `mint_invariant_snapshot`

**Purpose:**  
Record which invariants document/version was in force for a group of transforms.

**Fields:**

- `id` — UUID, PK  
- `mint_version` — TEXT, not null  
- `invariants_version` — TEXT, not null (e.g. `"v0.2"`)  
- `invariants_hash` — TEXT, not null (hash of invariants doc)  
- `recorded_at` — TIMESTAMPTZ, default `now()`  

---

### 3.2 `mint_transform_packet`

**Purpose:**  
Represent one logical execution of Mint for a given term version and Mint/invariants version.

**Fields:**

- `id` — UUID, PK  
- `term_id` — TEXT, not null  
- `term_version_id` — TEXT, not null  
- `invariant_snapshot_id` — UUID, nullable, FK → `mint_invariant_snapshot.id`  
- `mint_version` — TEXT, not null  
- `bundle_mode` — ENUM(`single`, `multi`), not null  
- `requested_tiers` — ARRAY of ENUM(`T1`, `T2`, `T3`), nullable  
- `requested_density` — ENUM(`light`, `medium`, `deep`), nullable  
- `created_at` — TIMESTAMPTZ, default `now()`  
- `integrity_hash` — TEXT, nullable (hash over packet + slices)  

**Notes:**

- This table is the anchor for a set of TierSlices.
- It binds together:
  - which term version,
  - which Mint version,
  - which invariants snapshot,
  - what was requested.

---

### 3.3 `mint_tier_slice`

**Purpose:**  
Store canonical TierSlices (T1/T2/T3) generated by Mint.

**Fields:**

- `id` — UUID, PK  
- `mint_transform_packet_id` — UUID, not null, FK → `mint_transform_packet.id`  
- `term_id` — TEXT, not null  
- `term_version_id` — TEXT, not null  

- `tier` — ENUM(`T1`, `T2`, `T3`), not null  
- `density` — ENUM(`light`, `medium`, `deep`), not null  

- `state` — ENUM(`canonical_current`, `canonical_stale`, `archived`, `invalidated`), not null  

- `content_md` — TEXT, not null  
- `content_json` — JSONB, nullable (optional structured representation)

- `nll_weight_who` — REAL, not null  
- `nll_weight_what` — REAL, not null  
- `nll_weight_how` — REAL, not null  
- `nll_weight_why` — REAL, not null  
- `nll_weight_where` — REAL, not null  
- `nll_weight_when` — REAL, not null  
- `nll_weight_whom_else` — REAL, not null  

- `embedding` — `vector(1536)`, nullable (Mint-specific embedding if used)  

- `created_at` — TIMESTAMPTZ, default `now()`  

**Notes:**

- Lifecycle state comes from **MINT_Slice_Lifecycle_v0.1**:
  - `canonical_current`
  - `canonical_stale`
  - `archived`
  - `invalidated`
- “Absent” = no row exists for that combination.
- “Variant” state is **not represented** (reserved concept only).

---

## 4. Example PostgreSQL DDL

> Note: ENUMs may be created in a migrations layer (e.g. Alembic) before tables.

```sql
CREATE TYPE mint_bundle_mode AS ENUM ('single', 'multi');
CREATE TYPE mint_tier AS ENUM ('T1', 'T2', 'T3');
CREATE TYPE mint_density AS ENUM ('light', 'medium', 'deep');
CREATE TYPE mint_slice_state AS ENUM ('canonical_current', 'canonical_stale', 'archived', 'invalidated');

CREATE TABLE mint_invariant_snapshot (
    id UUID PRIMARY KEY,
    mint_version TEXT NOT NULL,
    invariants_version TEXT NOT NULL,
    invariants_hash TEXT NOT NULL,
    recorded_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE mint_transform_packet (
    id UUID PRIMARY KEY,
    term_id TEXT NOT NULL,
    term_version_id TEXT NOT NULL,
    invariant_snapshot_id UUID REFERENCES mint_invariant_snapshot(id),
    mint_version TEXT NOT NULL,
    bundle_mode mint_bundle_mode NOT NULL,
    requested_tiers mint_tier[] NULL,
    requested_density mint_density NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    integrity_hash TEXT NULL
);

CREATE TABLE mint_tier_slice (
    id UUID PRIMARY KEY,
    mint_transform_packet_id UUID NOT NULL REFERENCES mint_transform_packet(id),
    term_id TEXT NOT NULL,
    term_version_id TEXT NOT NULL,
    tier mint_tier NOT NULL,
    density mint_density NOT NULL,
    state mint_slice_state NOT NULL,
    content_md TEXT NOT NULL,
    content_json JSONB NULL,
    nll_weight_who REAL NOT NULL,
    nll_weight_what REAL NOT NULL,
    nll_weight_how REAL NOT NULL,
    nll_weight_why REAL NOT NULL,
    nll_weight_where REAL NOT NULL,
    nll_weight_when REAL NOT NULL,
    nll_weight_whom_else REAL NOT NULL,
    embedding vector(1536),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Suggested indexes
CREATE INDEX idx_mint_transform_packet_term_version
    ON mint_transform_packet (term_id, term_version_id, mint_version);

CREATE INDEX idx_mint_tier_slice_lookup
    ON mint_tier_slice (term_id, term_version_id, tier, density, state);

CREATE INDEX idx_mint_tier_slice_packet
    ON mint_tier_slice (mint_transform_packet_id);
```

---

## 5. SQLAlchemy Models (Draft v0.2)

```python
from sqlalchemy import (
    Column, String, Text, Enum, DateTime, ForeignKey, Float, ARRAY
)
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import declarative_base, relationship
from pgvector.sqlalchemy import Vector
import enum
import uuid
from datetime import datetime

Base = declarative_base()

class Tier(enum.Enum):
    T1 = "T1"
    T2 = "T2"
    T3 = "T3"

class Density(enum.Enum):
    LIGHT = "light"
    MEDIUM = "medium"
    DEEP = "deep"

class BundleMode(enum.Enum):
    SINGLE = "single"
    MULTI = "multi"

class SliceState(enum.Enum):
    CANONICAL_CURRENT = "canonical_current"
    CANONICAL_STALE = "canonical_stale"
    ARCHIVED = "archived"
    INVALIDATED = "invalidated"


class MintInvariantSnapshot(Base):
    __tablename__ = "mint_invariant_snapshot"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    mint_version = Column(String, nullable=False)
    invariants_version = Column(String, nullable=False)
    invariants_hash = Column(String, nullable=False)
    recorded_at = Column(DateTime(timezone=True), default=datetime.utcnow)

    transform_packets = relationship("MintTransformPacket", back_populates="invariant_snapshot")


class MintTransformPacket(Base):
    __tablename__ = "mint_transform_packet"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    term_id = Column(String, nullable=False)
    term_version_id = Column(String, nullable=False)

    invariant_snapshot_id = Column(
        UUID(as_uuid=True),
        ForeignKey("mint_invariant_snapshot.id"),
        nullable=True,
    )

    mint_version = Column(String, nullable=False)
    bundle_mode = Column(Enum(BundleMode), nullable=False)
    requested_tiers = Column(ARRAY(Enum(Tier)), nullable=True)
    requested_density = Column(Enum(Density), nullable=True)
    created_at = Column(DateTime(timezone=True), default=datetime.utcnow)
    integrity_hash = Column(String, nullable=True)

    invariant_snapshot = relationship(
        "MintInvariantSnapshot", back_populates="transform_packets"
    )
    tier_slices = relationship("MintTierSlice", back_populates="packet")


class MintTierSlice(Base):
    __tablename__ = "mint_tier_slice"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    mint_transform_packet_id = Column(
        UUID(as_uuid=True),
        ForeignKey("mint_transform_packet.id"),
        nullable=False,
    )

    term_id = Column(String, nullable=False)
    term_version_id = Column(String, nullable=False)

    tier = Column(Enum(Tier), nullable=False)
    density = Column(Enum(Density), nullable=False)
    state = Column(Enum(SliceState), nullable=False)

    content_md = Column(Text, nullable=False)
    content_json = Column(JSONB, nullable=True)

    nll_weight_who = Column(Float, nullable=False)
    nll_weight_what = Column(Float, nullable=False)
    nll_weight_how = Column(Float, nullable=False)
    nll_weight_why = Column(Float, nullable=False)
    nll_weight_where = Column(Float, nullable=False)
    nll_weight_when = Column(Float, nullable=False)
    nll_weight_whom_else = Column(Float, nullable=False)

    embedding = Column(Vector(1536), nullable=True)

    created_at = Column(DateTime(timezone=True), default=datetime.utcnow)

    packet = relationship("MintTransformPacket", back_populates="tier_slices")
```

---

## 6. Alignment with MINT Slice Lifecycle

This schema supports the lifecycle states from `MINT_Slice_Lifecycle_v0.1`:

- **Absent** → no `mint_tier_slice` row exists for a given `(term_version_id, tier, density, mint_version)`.
- **Canonical-Current** → row exists with `state = 'canonical_current'`.
- **Canonical-Stale** → state updated to `'canonical_stale'` after regeneration.
- **Archived** → either state `'archived'` or moved to a history table (future option).
- **Invalidated** → state `'invalidated'` if slices are no longer valid.

Variation mode is **not represented** here and remains purely conceptual in the lifecycle document.

---

## 7. Usage Notes for Coding LLMs

1. **Do not duplicate GlossRP data.**  
   - Always treat `term_id` / `term_version_id` as references to external GlossRP structures.

2. **Use MintTransformPacket as the entry point.**  
   - Create a packet when generating slices for a term version.  
   - Attach all generated TierSlices to that packet.

3. **Respect lifecycle and state.**  
   - When regenerating, mark old slices as stale/archived before inserting new ones.  
   - Only slices with `state = 'canonical_current'` should be used for semantic reasoning.

4. **Avoid adding temperature or variation fields.**  
   - Canonical Mint is deterministic in this schema.  
   - Experimental behavior, if ever implemented, must live outside this canonical schema.

