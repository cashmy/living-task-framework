<#
.SYNOPSIS
  Fix common markdown linting errors in files generated by LLMs.

.DESCRIPTION
  Automatically fixes the most common markdown linting violations:
  - MD001: Heading levels should only increment by one level at a time
  - MD004: Unordered list style (standardizes to dashes)
  - MD009: Trailing spaces
  - MD010: Hard tabs (replaces with spaces)
  - MD012: Multiple consecutive blank lines
  - MD022: Headings should be surrounded by blank lines
  - MD030: Spaces after list markers
  - MD031: Fenced code blocks should be surrounded by blank lines
  - MD032: Lists should be surrounded by blank lines
  - MD040: Fenced code blocks should have a language specified

.PARAMETER FilePath
  Path to the markdown file to fix. Can be a single file or pattern (e.g., *.md).

.PARAMETER TabWidth
  Number of spaces to replace tabs with. Default: 2

.PARAMETER DefaultLanguage
  Default language to use for code blocks without a language specified. Default: text

.PARAMETER InPlace
  Modify the file in place. If not specified, creates a .fixed.md file.

.PARAMETER Backup
  Create a backup file before modifying. Only used with -InPlace.

.EXAMPLE
  pwsh tools/scripts/Fix-MarkdownLint.ps1 -FilePath README.md -InPlace

.EXAMPLE
  pwsh tools/scripts/Fix-MarkdownLint.ps1 -FilePath "docs/*.md" -DefaultLanguage javascript

.EXAMPLE
  pwsh tools/scripts/Fix-MarkdownLint.ps1 -FilePath myfile.md -InPlace -Backup
#>

param(
  [Parameter(Mandatory=$true)]
  [string]$FilePath,
  [int]$TabWidth = 2,
  [string]$DefaultLanguage = "text",
  [switch]$InPlace,
  [switch]$Backup
)

$ErrorActionPreference = "Stop"

function Repair-MD010HardTabs {
  param([string[]]$Lines, [int]$Width)
  $spaces = " " * $Width
  return $Lines | ForEach-Object { $_ -replace "`t", $spaces }
}

function Repair-MD001HeadingLevels {
  param([string[]]$Lines)
  $result = @()
  $lastLevel = 0
  
  foreach ($line in $Lines) {
    if ($line -match '^(#{1,6})\s+(.+)$') {
      $currentLevel = $matches[1].Length
      $content = $matches[2]
      
      # If jumping more than one level, adjust to proper increment
      $levelJump = $currentLevel - $lastLevel
      if ($levelJump -gt 1 -and $lastLevel -gt 0) {
        $currentLevel = $lastLevel + 1
      }
      
      $result += ("#" * $currentLevel) + " " + $content
      $lastLevel = $currentLevel
    } else {
      $result += $line
    }
  }
  
  return $result
}

function Repair-MD004UnorderedListStyle {
  param([string[]]$Lines)
  $result = @()
  
  foreach ($line in $Lines) {
    # Replace asterisk (*) or plus (+) with dash (-) for unordered lists
    if ($line -match '^(\s*)([*+])(\s+.*)$') {
      $indent = $matches[1]
      $content = $matches[3]
      $result += "$indent-$content"
    } else {
      $result += $line
    }
  }
  
  return $result
}

function Repair-MD022HeadingBlanks {
  param([string[]]$Lines)
  $result = @()
  $i = 0
  
  while ($i -lt $Lines.Count) {
    $line = $Lines[$i]
    
    if ($line -match '^#{1,6}\s+') {
      # Check if previous line exists and is not blank
      if ($result.Count -gt 0 -and $result[-1] -ne "") {
        $result += ""
      }
      
      $result += $line
      
      # Check if next line exists and is not blank
      if ($i + 1 -lt $Lines.Count -and $Lines[$i + 1] -ne "") {
        $result += ""
      }
    } else {
      $result += $line
    }
    
    $i++
  }
  
  return $result
}

function Repair-MD031MD040CodeBlocks {
  param([string[]]$Lines, [string]$DefaultLang)
  $result = @()
  $i = 0
  $inCodeBlock = $false
  
  while ($i -lt $Lines.Count) {
    $line = $Lines[$i]
    
    # Detect code block fence
    if ($line -match '^```(.*)$') {
      $lang = $matches[1].Trim()
      
      if (-not $inCodeBlock) {
        # Opening fence
        # MD031: Add blank line before if needed
        if ($result.Count -gt 0 -and $result[-1] -ne "") {
          $result += ""
        }
        
        # MD040: Add language if missing
        if ([string]::IsNullOrWhiteSpace($lang)) {
          $result += "``````$DefaultLang"
        } else {
          $result += $line
        }
        
        $inCodeBlock = $true
      } else {
        # Closing fence
        $result += $line
        $inCodeBlock = $false
        
        # MD031: Add blank line after if needed
        if ($i + 1 -lt $Lines.Count -and $Lines[$i + 1] -ne "") {
          $result += ""
        }
      }
    } else {
      $result += $line
    }
    
    $i++
  }
  
  return $result
}

function Repair-MD032ListBlanks {
  param([string[]]$Lines)
  $result = @()
  $i = 0
  $inList = $false
  
  while ($i -lt $Lines.Count) {
    $line = $Lines[$i]
    $isListItem = $line -match '^\s*[-*+]\s+' -or $line -match '^\s*\d+\.\s+'
    
    if ($isListItem) {
      if (-not $inList) {
        # Starting a list - add blank line before if needed
        if ($result.Count -gt 0 -and $result[-1] -ne "") {
          $result += ""
        }
        $inList = $true
      }
      $result += $line
    } else {
      if ($inList -and $line -ne "") {
        # Ending a list - add blank line after
        $result += ""
        $inList = $false
      }
      $result += $line
    }
    
    $i++
  }
  
  return $result
}

function Repair-MD009TrailingSpaces {
  param([string[]]$Lines)
  return $Lines | ForEach-Object { $_.TrimEnd() }
}

function Repair-MD012MultipleBlankLines {
  param([string[]]$Lines)
  $result = @()
  $blankCount = 0
  
  foreach ($line in $Lines) {
    if ($line -eq "") {
      $blankCount++
      if ($blankCount -le 1) {
        $result += $line
      }
    } else {
      $blankCount = 0
      $result += $line
    }
  }
  
  return $result
}

function Repair-MD030ListMarkerSpaces {
  param([string[]]$Lines)
  $result = @()
  
  foreach ($line in $Lines) {
    # Match unordered list items (-, *, +) with incorrect spacing
    if ($line -match '^(\s*)([-*+])(\s*)(.*)$') {
      $indent = $matches[1]
      $marker = $matches[2]
      $spaces = $matches[3]
      $content = $matches[4]
      
      # Ensure exactly one space after marker
      if ($spaces -ne " " -and $content -ne "") {
        $result += "$indent$marker $content"
      } else {
        $result += $line
      }
    }
    # Match ordered list items (1., 2., etc.) with incorrect spacing
    elseif ($line -match '^(\s*)(\d+\.)(\s*)(.*)$') {
      $indent = $matches[1]
      $marker = $matches[2]
      $spaces = $matches[3]
      $content = $matches[4]
      
      # Ensure exactly one space after marker
      if ($spaces -ne " " -and $content -ne "") {
        $result += "$indent$marker $content"
      } else {
        $result += $line
      }
    }
    else {
      $result += $line
    }
  }
  
  return $result
}

function Remove-ExcessiveBlankLines {
  param([string[]]$Lines)
  $result = @()
  $lastWasBlank = $false
  
  foreach ($line in $Lines) {
    if ($line -eq "") {
      if (-not $lastWasBlank) {
        $result += $line
        $lastWasBlank = $true
      }
    } else {
      $result += $line
      $lastWasBlank = $false
    }
  }
  
  return $result
}

# Main processing
$files = Get-Item $FilePath -ErrorAction Stop

if (-not $files) {
  throw "No files found matching: $FilePath"
}

foreach ($file in $files) {
  Write-Host "Processing: $($file.FullName)" -ForegroundColor Cyan
  
  # Read file
  $content = Get-Content -Path $file.FullName -Raw
  $lines = $content -split "`r?`n"
  
  Write-Host "  [1/10] Fixing MD009 (trailing spaces)..." -ForegroundColor Gray
  $lines = Repair-MD009TrailingSpaces -Lines $lines
  
  Write-Host "  [2/10] Fixing MD010 (hard tabs)..." -ForegroundColor Gray
  $lines = Repair-MD010HardTabs -Lines $lines -Width $TabWidth
  
  Write-Host "  [3/10] Fixing MD001 (heading levels)..." -ForegroundColor Gray
  $lines = Repair-MD001HeadingLevels -Lines $lines
  
  Write-Host "  [4/10] Fixing MD004 (unordered list style)..." -ForegroundColor Gray
  $lines = Repair-MD004UnorderedListStyle -Lines $lines
  
  Write-Host "  [5/10] Fixing MD022 (heading blanks)..." -ForegroundColor Gray
  $lines = Repair-MD022HeadingBlanks -Lines $lines
  
  Write-Host "  [6/10] Fixing MD030 (list marker spaces)..." -ForegroundColor Gray
  $lines = Repair-MD030ListMarkerSpaces -Lines $lines
  
  Write-Host "  [7/10] Fixing MD031/MD040 (code blocks)..." -ForegroundColor Gray
  $lines = Repair-MD031MD040CodeBlocks -Lines $lines -DefaultLang $DefaultLanguage
  
  Write-Host "  [8/10] Fixing MD032 (list blanks)..." -ForegroundColor Gray
  $lines = Repair-MD032ListBlanks -Lines $lines
  
  Write-Host "  [9/10] Fixing MD012 (multiple blank lines)..." -ForegroundColor Gray
  $lines = Repair-MD012MultipleBlankLines -Lines $lines
  
  Write-Host "  [10/10] Final cleanup..." -ForegroundColor Gray
  $lines = Remove-ExcessiveBlankLines -Lines $lines
  
  # Determine output path
  if ($InPlace) {
    if ($Backup) {
      $backupPath = $file.FullName + ".bak"
      Copy-Item $file.FullName $backupPath -Force
      Write-Host "  Backup created: $backupPath" -ForegroundColor Yellow
    }
    $outputPath = $file.FullName
  } else {
    $outputPath = [System.IO.Path]::ChangeExtension($file.FullName, ".fixed.md")
  }
  
  # Write output
  $lines -join "`n" | Set-Content -Path $outputPath -Encoding UTF8 -NoNewline
  
  Write-Host "  [✓] Fixed file written to: $outputPath" -ForegroundColor Green
}

Write-Host "`n[✓] All files processed successfully!" -ForegroundColor Green
